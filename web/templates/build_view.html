{{define "content"}}
<link rel="stylesheet" href="/static/css/build.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">

<section class="build-shell">
    <section class="build-hero">
        <div class="build-hero-top">
            <div>
                <h1 class="build-title">{{.Project.Name}} Build</h1>
                <p class="build-subline">{{if .Project.RunID}}Run: {{.Project.RunID}}{{else}}Preparing run...{{end}}</p>
            </div>
            <div class="web-inline-actions" style="margin-top: 0;">
                <div id="build-status-pill" class="build-pill">
                    <span class="build-pill-dot"></span>
                    <span id="build-status-text">connecting</span>
                </div>
                <form method="POST" action="/projects/{{.Project.ID}}/build/stop" class="build-stop-form">
                    <button type="submit" class="btn btn-danger">Stop</button>
                </form>
            </div>
        </div>
        <section class="build-graph-shell">
            <div class="build-graph-head">
                <h2 class="build-graph-title">Pipeline Diagram</h2>
                <span id="build-graph-status" class="build-graph-status">Rendering diagramâ€¦</span>
            </div>
            <div id="build-graph" class="build-graph">
                <div class="build-graph-empty">Rendering pipeline diagram...</div>
            </div>
        </section>
        <div class="build-metrics">
            <div class="build-metric">
                <p class="build-metric-label">Current Node</p>
                <p id="metric-current-node" class="build-metric-value">-</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Completed Nodes</p>
                <p id="metric-completed-count" class="build-metric-value">0</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Connection</p>
                <p id="metric-connection" class="build-metric-value">Connecting</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Tool Calls</p>
                <p id="metric-tool-calls" class="build-metric-value">0</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Elapsed</p>
                <p id="metric-elapsed" class="build-metric-value">00:00</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Last Activity</p>
                <p id="metric-last-activity" class="build-metric-value">Waiting</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Total Tokens</p>
                <p id="metric-total-tokens" class="build-metric-value">0</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Build Pulse</p>
                <p id="metric-pulse" class="build-metric-value">Starting</p>
            </div>
        </div>
    </section>

    <div class="build-tab-bar">
        <button class="build-tab active" data-tab="console">Console</button>
        <button class="build-tab" data-tab="metrics">Metrics</button>
    </div>

    <div id="tab-console" class="build-tab-panel active">
        <div id="build-console" class="build-console">
            <div class="build-console-empty">Waiting for agent activity...</div>
        </div>
    </div>

    <div id="tab-metrics" class="build-tab-panel">
    <section class="build-grid">
        <section class="build-card">
            <div class="build-card-head">
                <h2 class="build-card-title">Live Timeline</h2>
                <div id="connection-badge" class="build-connection">
                    <span class="build-connection-dot"></span>
                    <span id="connection-text">connecting</span>
                </div>
            </div>
            <div id="build-events" class="build-events">
                <div class="build-empty">Connecting to build events...</div>
            </div>
        </section>

        <div class="build-side">
            <section class="build-card">
                <div class="build-card-head">
                    <h2 class="build-card-title">Completed Nodes</h2>
                </div>
                <div id="completed-nodes" class="build-nodes"></div>
            </section>
            <section class="build-card">
                <div class="build-card-head">
                    <h2 class="build-card-title">Token Usage by Node</h2>
                </div>
                <ul id="token-nodes" class="token-list">
                    <li class="token-item"><span class="token-node">No token usage yet</span><span class="token-total">0</span></li>
                </ul>
            </section>
        </div>
    </section>
    </div>
</section>

<script src="/static/js/viz-render.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@viz-js/viz@3.11.0/lib/viz-standalone.js"></script>
<script>
(function() {
    var projectID = '{{.Project.ID}}';
    var projectDOT = {{ printf "%q" .Project.DOT }};
    var finalURL = '/projects/' + projectID + '/final';
    var stateURL = '/projects/' + projectID + '/build/state';
    var eventsURL = '/projects/' + projectID + '/build/events';

    var eventsDiv = document.getElementById('build-events');
    var nodesContainer = document.getElementById('completed-nodes');
    var metricCurrentNode = document.getElementById('metric-current-node');
    var metricCompletedCount = document.getElementById('metric-completed-count');
    var metricConnection = document.getElementById('metric-connection');
    var metricToolCalls = document.getElementById('metric-tool-calls');
    var metricElapsed = document.getElementById('metric-elapsed');
    var metricLastActivity = document.getElementById('metric-last-activity');
    var metricTotalTokens = document.getElementById('metric-total-tokens');
    var metricPulse = document.getElementById('metric-pulse');
    var tokenNodesList = document.getElementById('token-nodes');
    var graphContainer = document.getElementById('build-graph');
    var graphStatus = document.getElementById('build-graph-status');
    var statusPill = document.getElementById('build-status-pill');
    var statusText = document.getElementById('build-status-text');
    var connectionBadge = document.getElementById('connection-badge');
    var connectionText = document.getElementById('connection-text');

    var source = null;
    var reconnectTimer = null;
    var seenCompletions = {};
    var seenEventKeys = {};
    var isTerminal = false;
    var toolCallsSeen = {};
    var toolCallCount = 0;
    var shouldReconnect = false;
    var elapsedTimer = null;
    var activityTimer = null;
    var startedAt = null;
    var lastActivityAt = null;
    var totalTokens = 0;
    var nodeTokenTotals = {};
    var tokenEventsSeen = {};
    var activeGraphNode = '';
    var redirectedToFinal = false;

    // Tab switching
    var tabs = document.querySelectorAll('.build-tab');
    tabs.forEach(function(tab) {
        tab.addEventListener('click', function() {
            tabs.forEach(function(t) { t.classList.remove('active'); });
            tab.classList.add('active');
            document.querySelectorAll('.build-tab-panel').forEach(function(p) {
                p.classList.remove('active');
            });
            document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
        });
    });

    // Console state
    var consoleDiv = document.getElementById('build-console');
    var consoleAutoScroll = true;
    var currentConsoleTextEl = null;

    var consoleResumeBar = null;
    var programmaticScroll = false;

    function showResumeBar() {
        if (consoleResumeBar) { return; }
        consoleResumeBar = document.createElement('div');
        consoleResumeBar.className = 'console-resume-bar';
        var btn = document.createElement('button');
        btn.className = 'console-resume-btn';
        btn.textContent = '\u25bc Resume auto-scroll';
        btn.addEventListener('click', function() {
            consoleAutoScroll = true;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            hideResumeBar();
        });
        consoleResumeBar.appendChild(btn);
        consoleDiv.appendChild(consoleResumeBar);
    }

    function hideResumeBar() {
        if (consoleResumeBar) {
            consoleResumeBar.remove();
            consoleResumeBar = null;
        }
    }

    consoleDiv.addEventListener('scroll', function() {
        if (programmaticScroll) { return; }
        var atBottom = consoleDiv.scrollHeight - consoleDiv.scrollTop - consoleDiv.clientHeight < 30;
        consoleAutoScroll = atBottom;
        if (atBottom) {
            hideResumeBar();
        } else {
            showResumeBar();
        }
    });

    function setStatus(status) {
        statusPill.classList.remove('running', 'completed', 'failed', 'cancelled');
        var text = status || 'unknown';
        if (status === 'running') {
            statusPill.classList.add('running');
        } else if (status === 'completed') {
            statusPill.classList.add('completed');
        } else if (status === 'failed') {
            statusPill.classList.add('failed');
        } else if (status === 'cancelled') {
            statusPill.classList.add('cancelled');
        }
        statusText.textContent = text;
        isTerminal = status === 'completed' || status === 'failed' || status === 'cancelled';
        if (status === 'running') {
            startElapsedTimer();
            metricPulse.textContent = 'Active';
        } else {
            stopElapsedTimer();
            stopActivityTimer();
            if (status === 'completed') {
                metricPulse.textContent = 'Complete';
            } else if (status === 'failed') {
                metricPulse.textContent = 'Failed';
            } else if (status === 'cancelled') {
                metricPulse.textContent = 'Stopped';
            }
        }
    }

    function setConnection(state) {
        connectionBadge.classList.remove('connected', 'reconnecting', 'offline');
        if (state === 'connected') {
            connectionBadge.classList.add('connected');
            connectionText.textContent = 'live';
            metricConnection.textContent = 'Live';
        } else if (state === 'reconnecting') {
            connectionBadge.classList.add('reconnecting');
            connectionText.textContent = 'reconnecting';
            metricConnection.textContent = 'Reconnecting';
        } else {
            connectionBadge.classList.add('offline');
            connectionText.textContent = 'offline';
            metricConnection.textContent = 'Offline';
        }
    }

    function consoleScrollToBottom() {
        if (consoleAutoScroll) {
            hideResumeBar();
            programmaticScroll = true;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            setTimeout(function() { programmaticScroll = false; }, 100);
        }
    }

    function consoleClearEmpty() {
        var empty = consoleDiv.querySelector('.build-console-empty');
        if (empty) { empty.remove(); }
    }

    function escapeHtml(str) {
        var div = document.createElement('div');
        div.appendChild(document.createTextNode(str || ''));
        return div.innerHTML;
    }

    function truncateStr(s, max) {
        if (!s || s.length <= max) { return s || ''; }
        return s.substring(0, max);
    }

    function appendConsoleHeader(nodeId, type) {
        consoleClearEmpty();
        var el = document.createElement('div');
        el.className = 'console-header';
        el.innerHTML = '<span class="console-node">node:' + escapeHtml(nodeId || '?') + '</span> \u25b8 <span class="console-type">' + escapeHtml(type) + '</span>';
        consoleDiv.appendChild(el);
        currentConsoleTextEl = null;
        consoleScrollToBottom();
    }

    function appendConsoleText(text) {
        consoleClearEmpty();
        if (!currentConsoleTextEl) {
            currentConsoleTextEl = document.createElement('div');
            currentConsoleTextEl.className = 'console-text';
            var cursor = document.createElement('span');
            cursor.className = 'console-cursor';
            currentConsoleTextEl.appendChild(cursor);
            consoleDiv.appendChild(currentConsoleTextEl);
        }
        var cursor = currentConsoleTextEl.querySelector('.console-cursor');
        if (cursor) {
            currentConsoleTextEl.insertBefore(document.createTextNode(text), cursor);
        } else {
            currentConsoleTextEl.appendChild(document.createTextNode(text));
        }
        consoleScrollToBottom();
    }

    function finishConsoleText() {
        if (currentConsoleTextEl) {
            var cursor = currentConsoleTextEl.querySelector('.console-cursor');
            if (cursor) { cursor.remove(); }
            currentConsoleTextEl = null;
        }
    }

    function appendConsoleToolInput(name, args) {
        consoleClearEmpty();
        finishConsoleText();
        var el = document.createElement('div');
        el.className = 'console-tool-input';
        var display = name || 'unknown';
        if (args) {
            try {
                var parsed = JSON.parse(args);
                if (parsed.command) {
                    display = '$ ' + parsed.command;
                } else {
                    display = name + '(' + truncateStr(args, 200) + ')';
                }
            } catch(_e) {
                display = name + '(' + truncateStr(args, 200) + ')';
            }
        }
        el.innerHTML = '<span class="console-prefix">\u25b8 </span>' + escapeHtml(display);
        consoleDiv.appendChild(el);
        consoleScrollToBottom();
    }

    function appendConsoleToolOutput(output, durationMs) {
        consoleClearEmpty();
        if (!output) { return; }
        var el = document.createElement('div');
        el.className = 'console-tool-output';
        var isTruncated = output.length > 500;
        var displayText = isTruncated ? truncateStr(output, 500) + '...' : output;
        var suffix = '';
        if (durationMs) {
            suffix = durationMs < 1000 ? ' (' + durationMs + 'ms)' : ' (' + (durationMs / 1000).toFixed(1) + 's)';
        }
        el.innerHTML = '<span class="console-prefix">&gt; </span>' + escapeHtml(displayText) + escapeHtml(suffix);
        el.setAttribute('data-full-output', output);
        el.setAttribute('data-suffix', suffix);
        consoleDiv.appendChild(el);
        if (isTruncated) {
            var toggle = document.createElement('button');
            toggle.className = 'console-expand-toggle';
            toggle.textContent = '\u25b6 Show full output (' + output.length + ' chars)';
            toggle.addEventListener('click', function() {
                var expanded = el.classList.toggle('expanded');
                if (expanded) {
                    el.innerHTML = '<span class="console-prefix">&gt; </span>' + escapeHtml(output) + escapeHtml(suffix);
                    toggle.textContent = '\u25bc Collapse output';
                } else {
                    el.innerHTML = '<span class="console-prefix">&gt; </span>' + escapeHtml(displayText) + escapeHtml(suffix);
                    toggle.textContent = '\u25b6 Show full output (' + output.length + ' chars)';
                }
            });
            consoleDiv.appendChild(toggle);
        }
        consoleScrollToBottom();
    }

    function appendConsoleSummary(tokens) {
        var el = document.createElement('div');
        el.className = 'console-summary';
        el.textContent = '(' + formatNumber(tokens || 0) + ' tokens)';
        consoleDiv.appendChild(el);
        consoleScrollToBottom();
    }

    function connectStream() {
        if (isTerminal || !shouldReconnect) {
            return;
        }
        if (source) {
            source.close();
        }
        source = new EventSource(eventsURL);
        setConnection('connected');

        source.addEventListener('pipeline.started', function() {
            addEvent('Pipeline started', 'success');
            setStatus('running');
        });

        source.addEventListener('stage.started', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            addEvent('Stage started: ' + node, 'normal');
            metricCurrentNode.textContent = node;
            setActiveNodeHighlight(node);
            appendConsoleHeader(node, 'stage started');
        });

        source.addEventListener('stage.completed', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            addEvent('Stage completed: ' + node, 'success');
            appendCompletedNode(node);
        });

        source.addEventListener('stage.failed', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            var reason = data.reason || data.error || '';
            addEvent('Stage failed: ' + node + (reason ? ' - ' + reason : ''), 'error');
        });

        source.addEventListener('stage.retrying', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            var attempt = data.attempt || data.retry_attempt || '';
            addEvent('Stage retrying: ' + node + (attempt ? ' (attempt ' + attempt + ')' : ''), 'muted');
        });

        source.addEventListener('stage.stalled', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            addEvent('Stage stalled: ' + node, 'error');
        });

        source.addEventListener('checkpoint.saved', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            addEvent('Checkpoint saved' + (node ? ': ' + node : ''), 'muted');
        });

        source.addEventListener('agent.text.start', function(e) {
            var data = safeJSON(e.data);
            appendConsoleHeader(data.node_id || metricCurrentNode.textContent, 'agent thinking...');
        });

        source.addEventListener('agent.text.delta', function(e) {
            var data = safeJSON(e.data);
            if (data.text) {
                appendConsoleText(data.text);
            }
        });

        source.addEventListener('agent.tool_call.start', function(e) {
            var data = safeJSON(e.data);
            registerToolCallStart(data);
            addEvent('Tool start: ' + toolSummary(data), 'normal');
            appendConsoleHeader(data.node_id || metricCurrentNode.textContent, 'tool_call: ' + (data.tool_name || 'unknown'));
            appendConsoleToolInput(data.tool_name, data.arguments);
        });

        source.addEventListener('agent.tool_call.end', function(e) {
            var data = safeJSON(e.data);
            addEvent('Tool done: ' + toolSummary(data) + toolDurationSuffix(data), 'success');
            appendConsoleToolOutput(data.output_snippet, data.duration_ms);
        });

        source.addEventListener('agent.llm_turn', function(e) {
            var data = safeJSON(e.data);
            finishConsoleText();
            appendConsoleSummary(data.total_tokens);
            registerLLMTurn(data);
            var inTokens = data.input_tokens || 0;
            var outTokens = data.output_tokens || 0;
            var totalTokens = data.total_tokens || (Number(inTokens) + Number(outTokens));
            addEvent('LLM turn: ' + totalTokens + ' tokens (in ' + inTokens + ', out ' + outTokens + ')', 'muted');
        });

        source.addEventListener('pipeline.completed', function() {
            addEvent('Pipeline completed', 'success');
            setStatus('completed');
            closeStream();
            refreshState();
            setTimeout(function() { window.location.href = finalURL; }, 900);
        });

        source.addEventListener('pipeline.failed', function(e) {
            var data = safeJSON(e.data);
            addEvent('Pipeline failed: ' + (data.error || 'unknown error'), 'error');
            setStatus('failed');
            closeStream();
            refreshState();
        });

        source.onerror = function() {
            closeStream();
            if (!shouldReconnect) {
                setConnection('offline');
                return;
            }
            setConnection('reconnecting');
            refreshState();
            if (shouldReconnect) {
                scheduleReconnect();
            }
        };
    }

    function closeStream() {
        if (source) {
            source.close();
            source = null;
        }
    }

    function scheduleReconnect() {
        if (reconnectTimer || isTerminal) {
            return;
        }
        reconnectTimer = setTimeout(function() {
            reconnectTimer = null;
            connectStream();
        }, 1800);
    }

    function refreshState() {
        fetch(stateURL, { headers: { 'Accept': 'application/json' } })
            .then(function(r) { return r.json(); })
            .then(function(state) {
                renderState(state);
                shouldReconnect = Boolean(state && state.active && !isTerminal);
                if (shouldReconnect && !source) {
                    connectStream();
                }
                if (!shouldReconnect) {
                    closeStream();
                    setConnection('offline');
                }
            })
            .catch(function() {
                addEvent('Unable to fetch build state', 'error');
            });
    }

    function renderState(state) {
        if (!state || typeof state !== 'object') {
            return;
        }
        if (state.status) {
            setStatus(state.status);
            if (state.status === 'completed' && !redirectedToFinal) {
                redirectedToFinal = true;
                setTimeout(function() { window.location.href = finalURL; }, 700);
            }
        }
        if (state.run_state) {
            if (state.run_state.started_at) {
                var parsedStart = new Date(state.run_state.started_at);
                if (!Number.isNaN(parsedStart.getTime())) {
                    startedAt = parsedStart;
                    updateElapsedMetric();
                }
            }
            if (state.run_state.current_node) {
                metricCurrentNode.textContent = state.run_state.current_node;
                setActiveNodeHighlight(state.run_state.current_node);
            }
            if (Array.isArray(state.run_state.completed_nodes)) {
                state.run_state.completed_nodes.forEach(function(nodeID) {
                    appendCompletedNode(nodeID);
                });
            }
        }
        if (Array.isArray(state.recent_events)) {
            state.recent_events.forEach(function(evt) {
                replayEvent(evt);
            });
        }
        if (Array.isArray(state.diagnostics) && state.diagnostics.length > 0 && state.status !== 'running') {
            addEvent(state.diagnostics[0], 'error');
        }
        metricCompletedCount.textContent = String(Object.keys(seenCompletions).length);
    }

    function replayEvent(evt) {
        if (!evt || !evt.event) {
            return;
        }
        var key = eventKey(evt.event, evt.data || '');
        if (seenEventKeys[key]) {
            return;
        }
        seenEventKeys[key] = true;

        var data = safeJSON(evt.data || '{}');
        if (evt.event === 'stage.completed') {
            appendCompletedNode(data.node_id || 'unknown');
            addEvent('Stage completed: ' + (data.node_id || 'unknown'), 'success');
        } else if (evt.event === 'stage.started') {
            addEvent('Stage started: ' + (data.node_id || 'unknown'), 'normal');
        } else if (evt.event === 'stage.failed') {
            addEvent('Stage failed: ' + (data.node_id || 'unknown'), 'error');
        } else if (evt.event === 'stage.retrying') {
            addEvent('Stage retrying: ' + (data.node_id || 'unknown'), 'muted');
        } else if (evt.event === 'stage.stalled') {
            addEvent('Stage stalled: ' + (data.node_id || 'unknown'), 'error');
        } else if (evt.event === 'checkpoint.saved') {
            addEvent('Checkpoint saved' + (data.node_id ? ': ' + data.node_id : ''), 'muted');
        } else if (evt.event === 'agent.tool_call.start') {
            registerToolCallStart(data);
            addEvent('Tool start: ' + toolSummary(data), 'normal');
        } else if (evt.event === 'agent.tool_call.end') {
            addEvent('Tool done: ' + toolSummary(data) + toolDurationSuffix(data), 'success');
        } else if (evt.event === 'agent.llm_turn') {
            registerLLMTurn(data);
            var inTokens = data.input_tokens || 0;
            var outTokens = data.output_tokens || 0;
            var totalTokens = data.total_tokens || (Number(inTokens) + Number(outTokens));
            addEvent('LLM turn: ' + totalTokens + ' tokens (in ' + inTokens + ', out ' + outTokens + ')', 'muted');
        } else if (evt.event === 'pipeline.completed') {
            addEvent('Pipeline completed', 'success');
        } else if (evt.event === 'pipeline.failed') {
            addEvent('Pipeline failed: ' + (data.error || 'unknown error'), 'error');
        } else if (evt.event === 'pipeline.started') {
            addEvent('Pipeline started', 'success');
        }
    }

    function registerToolCallStart(data) {
        if (!data || typeof data !== 'object') {
            return;
        }
        var callID = data.call_id || '';
        if (callID && toolCallsSeen[callID]) {
            return;
        }
        if (callID) {
            toolCallsSeen[callID] = true;
        }
        toolCallCount += 1;
        metricToolCalls.textContent = String(toolCallCount);
    }

    function toolSummary(data) {
        var tool = (data && data.tool_name) ? String(data.tool_name) : 'unknown tool';
        var node = (data && data.node_id) ? String(data.node_id) : '';
        if (node) {
            return tool + ' @ ' + node;
        }
        return tool;
    }

    function toolDurationSuffix(data) {
        if (!data || typeof data !== 'object') {
            return '';
        }
        var ms = Number(data.duration_ms || 0);
        if (!ms || Number.isNaN(ms)) {
            return '';
        }
        if (ms < 1000) {
            return ' (' + ms + 'ms)';
        }
        return ' (' + (ms / 1000).toFixed(2) + 's)';
    }

    function appendCompletedNode(nodeID) {
        if (!nodeID || seenCompletions[nodeID]) {
            return;
        }
        seenCompletions[nodeID] = true;
        var chip = document.createElement('span');
        chip.className = 'build-node-chip';
        chip.textContent = nodeID;
        nodesContainer.appendChild(chip);
        metricCompletedCount.textContent = String(Object.keys(seenCompletions).length);
    }

    function registerLLMTurn(data) {
        if (!data || typeof data !== 'object') {
            return;
        }
        var key = 'llm::' + String(data.turn_id || data.message_id || data.timestamp || JSON.stringify(data));
        if (tokenEventsSeen[key]) {
            return;
        }
        tokenEventsSeen[key] = true;

        var inTokens = Number(data.input_tokens || 0);
        var outTokens = Number(data.output_tokens || 0);
        var turnTotal = Number(data.total_tokens || (inTokens + outTokens));
        if (!Number.isFinite(turnTotal) || turnTotal <= 0) {
            return;
        }

        totalTokens += turnTotal;
        metricTotalTokens.textContent = formatNumber(totalTokens);

        var node = String(data.node_id || metricCurrentNode.textContent || 'unknown');
        if (!nodeTokenTotals[node]) {
            nodeTokenTotals[node] = 0;
        }
        nodeTokenTotals[node] += turnTotal;
        renderNodeTokenTotals();
    }

    function renderNodeTokenTotals() {
        var entries = Object.keys(nodeTokenTotals).map(function(node) {
            return { node: node, total: nodeTokenTotals[node] };
        });
        entries.sort(function(a, b) { return b.total - a.total; });

        if (entries.length === 0) {
            tokenNodesList.innerHTML = '<li class="token-item"><span class="token-node">No token usage yet</span><span class="token-total">0</span></li>';
            return;
        }

        tokenNodesList.innerHTML = '';
        entries.forEach(function(entry) {
            var li = document.createElement('li');
            li.className = 'token-item';

            var nameEl = document.createElement('span');
            nameEl.className = 'token-node';
            nameEl.textContent = entry.node;

            var totalEl = document.createElement('span');
            totalEl.className = 'token-total';
            totalEl.textContent = formatNumber(entry.total);

            li.appendChild(nameEl);
            li.appendChild(totalEl);
            tokenNodesList.appendChild(li);
        });
    }

    function renderPipelineGraph() {
        if (!projectDOT || !projectDOT.trim()) {
            graphStatus.textContent = 'No DOT';
            graphContainer.innerHTML = '<div class="build-graph-empty">No DOT available for this build.</div>';
            return;
        }

        if (typeof Viz === 'undefined') {
            graphStatus.textContent = 'Renderer unavailable';
            graphContainer.innerHTML = '<div class="build-graph-empty">Diagram renderer did not load.</div>';
            return;
        }

        var dotText = mammothViz.normalizeDOTSource(projectDOT);
        mammothViz.renderDOTToSVG(dotText).then(function(svg) {
            graphContainer.innerHTML = svg;
            var svgEl = graphContainer.querySelector('svg');
            if (svgEl) {
                svgEl.classList.add('build-graph-svg');
                svgEl.removeAttribute('width');
                svgEl.removeAttribute('height');
            }
            graphStatus.textContent = 'Live highlighting on';
            if (activeGraphNode) {
                setActiveNodeHighlight(activeGraphNode);
            }
        }).catch(function(err) {
            graphStatus.textContent = 'Render failed';
            var msg = (err && err.message) ? String(err.message) : 'unknown error';
            graphContainer.innerHTML = '<div class="build-graph-empty">Could not render DOT diagram: ' + mammothViz.escapeHTML(msg) + '</div>';
        });
    }

    function setActiveNodeHighlight(nodeID) {
        if (!nodeID || !graphContainer) {
            return;
        }
        activeGraphNode = String(nodeID);
        mammothViz.setActiveNodeHighlight(nodeID, graphContainer, graphStatus);
    }

    function eventKey(event, data) {
        return event + '::' + String(data || '');
    }

    function safeJSON(text) {
        try {
            return JSON.parse(text);
        } catch (_e) {
            return {};
        }
    }

    function formatNumber(n) {
        var num = Number(n || 0);
        if (!Number.isFinite(num)) {
            return '0';
        }
        return Math.floor(num).toLocaleString();
    }

    function addEvent(text, tone) {
        if (!text) {
            return;
        }
        lastActivityAt = new Date();
        updateLastActivityMetric();
        if (eventsDiv.querySelector('.build-empty')) {
            eventsDiv.innerHTML = '';
        }
        var card = document.createElement('article');
        card.className = 'build-event';
        if (tone === 'success') {
            card.classList.add('success');
        } else if (tone === 'error') {
            card.classList.add('error');
        } else if (tone === 'muted') {
            card.classList.add('muted');
        }

        var timeEl = document.createElement('p');
        timeEl.className = 'build-event-time';
        timeEl.textContent = new Date().toLocaleTimeString();

        var textEl = document.createElement('p');
        textEl.className = 'build-event-text';
        textEl.textContent = text;

        card.appendChild(timeEl);
        card.appendChild(textEl);
        eventsDiv.appendChild(card);
        eventsDiv.scrollTop = eventsDiv.scrollHeight;
    }

    function startElapsedTimer() {
        if (!startedAt) {
            startedAt = new Date();
        }
        if (elapsedTimer) {
            return;
        }
        updateElapsedMetric();
        elapsedTimer = setInterval(updateElapsedMetric, 1000);
        startActivityTimer();
    }

    function stopElapsedTimer() {
        if (!elapsedTimer) {
            return;
        }
        clearInterval(elapsedTimer);
        elapsedTimer = null;
    }

    function startActivityTimer() {
        if (activityTimer) {
            return;
        }
        updateLastActivityMetric();
        activityTimer = setInterval(updateLastActivityMetric, 1000);
    }

    function stopActivityTimer() {
        if (!activityTimer) {
            return;
        }
        clearInterval(activityTimer);
        activityTimer = null;
    }

    function updateElapsedMetric() {
        if (!startedAt) {
            metricElapsed.textContent = '00:00';
            return;
        }
        var seconds = Math.max(0, Math.floor((Date.now() - startedAt.getTime()) / 1000));
        var mins = Math.floor(seconds / 60);
        var secs = seconds % 60;
        metricElapsed.textContent = String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
    }

    function updateLastActivityMetric() {
        if (!lastActivityAt) {
            metricLastActivity.textContent = 'Waiting';
            return;
        }
        var seconds = Math.max(0, Math.floor((Date.now() - lastActivityAt.getTime()) / 1000));
        if (seconds < 5) {
            metricLastActivity.textContent = 'Just now';
            metricPulse.textContent = 'Active';
            return;
        }
        metricLastActivity.textContent = seconds + 's ago';
        metricPulse.textContent = seconds > 20 ? ('Quiet ' + seconds + 's') : 'Active';
    }

    renderPipelineGraph();
    refreshState();
    startActivityTimer();
})();
</script>
{{end}}
