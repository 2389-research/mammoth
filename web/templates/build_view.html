{{define "content"}}
<style>
    .build-shell {
        display: grid;
        gap: 16px;
    }
    .build-hero {
        position: relative;
        overflow: hidden;
        border-radius: var(--radius-2xl);
        border: 1px solid color-mix(in srgb, var(--border) 84%, #0ea5e9 16%);
        background:
            radial-gradient(circle at 88% 20%, color-mix(in srgb, #0ea5e9 22%, transparent), transparent 42%),
            radial-gradient(circle at 12% 0%, color-mix(in srgb, #22c55e 18%, transparent), transparent 32%),
            linear-gradient(145deg, color-mix(in srgb, var(--bg-card) 80%, #f8fafc 20%), var(--bg-card));
        padding: 20px;
        box-shadow: 0 20px 60px color-mix(in srgb, #0f172a 14%, transparent);
    }
    .build-graph-shell {
        margin-top: 14px;
        border-radius: var(--radius-2xl);
        border: 1px solid var(--border);
        background: color-mix(in srgb, var(--bg-card) 92%, #fff 8%);
        overflow: hidden;
    }
    .build-graph-head {
        border-bottom: 1px solid var(--border);
        padding: 10px 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
    }
    .build-graph-title {
        margin: 0;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-muted);
    }
    .build-graph-status {
        font-size: 12px;
        color: var(--text-secondary);
    }
    .build-graph {
        max-height: 300px;
        overflow: auto;
        padding: 10px;
        background: color-mix(in srgb, var(--bg-secondary) 90%, #fff 10%);
    }
    .build-graph-empty {
        margin: 6px;
        padding: 12px;
        border: 1px dashed var(--border);
        border-radius: var(--radius-xl);
        color: var(--text-secondary);
        font-size: 13px;
        text-align: center;
    }
    .build-graph-svg {
        width: 100%;
        min-width: 640px;
    }
    .build-graph-svg g.node.is-active ellipse,
    .build-graph-svg g.node.is-active polygon,
    .build-graph-svg g.node.is-active path {
        stroke: #f59e0b !important;
        stroke-width: 3 !important;
        fill: color-mix(in srgb, #fef3c7 72%, white 28%) !important;
        filter: drop-shadow(0 0 6px rgba(245, 158, 11, 0.35));
    }
    .build-hero::after {
        content: "";
        position: absolute;
        top: -65px;
        right: -50px;
        width: 170px;
        height: 170px;
        border-radius: 999px;
        border: 2px solid color-mix(in srgb, #38bdf8 30%, transparent);
        pointer-events: none;
    }
    .build-hero-top {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 14px;
        flex-wrap: wrap;
    }
    .build-title {
        margin: 0;
        font-family: var(--font-display);
        font-size: clamp(1.4rem, 2.3vw, 1.9rem);
        line-height: 1.1;
        letter-spacing: 0.01em;
    }
    .build-subline {
        margin: 6px 0 0 0;
        color: var(--text-secondary);
        font-size: 13px;
    }
    .build-pill {
        border-radius: 999px;
        border: 1px solid var(--border);
        background: color-mix(in srgb, var(--bg-secondary) 90%, #fff 10%);
        padding: 8px 12px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--text-secondary);
    }
    .build-pill-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--text-muted);
    }
    .build-pill.running {
        color: color-mix(in srgb, #0f766e 78%, var(--text-primary) 22%);
    }
    .build-pill.running .build-pill-dot {
        background: #14b8a6;
        box-shadow: 0 0 0 0 rgba(20, 184, 166, 0.55);
        animation: buildPulse 1.6s infinite;
    }
    .build-pill.completed {
        color: #166534;
    }
    .build-pill.completed .build-pill-dot {
        background: #22c55e;
    }
    .build-pill.failed {
        color: #991b1b;
    }
    .build-pill.failed .build-pill-dot {
        background: #ef4444;
    }
    .build-pill.cancelled {
        color: #b45309;
    }
    .build-pill.cancelled .build-pill-dot {
        background: #f59e0b;
    }
    .build-metrics {
        margin-top: 16px;
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 10px;
    }
    .build-metric {
        border-radius: var(--radius-xl);
        border: 1px solid color-mix(in srgb, var(--border) 86%, #e2e8f0 14%);
        background: color-mix(in srgb, var(--bg-card) 85%, #fff 15%);
        padding: 10px 12px;
    }
    .build-metric-label {
        margin: 0;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-muted);
        font-weight: 700;
    }
    .build-metric-value {
        margin: 4px 0 0 0;
        font-size: 15px;
        font-weight: 700;
        color: var(--text-primary);
        overflow-wrap: anywhere;
    }
    .build-grid {
        display: grid;
        grid-template-columns: 1.4fr 1fr;
        gap: 14px;
    }
    .build-side {
        display: grid;
        gap: 14px;
        align-content: start;
    }
    .build-card {
        border-radius: var(--radius-2xl);
        border: 1px solid var(--border);
        background: var(--bg-card);
        box-shadow: 0 12px 30px color-mix(in srgb, #0f172a 6%, transparent);
        overflow: hidden;
    }
    .build-card-head {
        border-bottom: 1px solid var(--border);
        padding: 12px 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
    }
    .build-card-title {
        margin: 0;
        font-size: 13px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--text-muted);
    }
    .build-connection {
        display: inline-flex;
        align-items: center;
        gap: 7px;
        font-size: 11px;
        color: var(--text-secondary);
    }
    .build-connection-dot {
        width: 7px;
        height: 7px;
        border-radius: 999px;
        background: var(--text-muted);
    }
    .build-connection.connected .build-connection-dot {
        background: #14b8a6;
    }
    .build-connection.reconnecting .build-connection-dot {
        background: #f59e0b;
    }
    .build-connection.offline .build-connection-dot {
        background: #ef4444;
    }
    .build-events {
        max-height: 480px;
        overflow: auto;
        padding: 8px 10px 12px 10px;
        display: grid;
        gap: 8px;
    }
    .build-empty {
        margin: 10px;
        padding: 14px;
        border: 1px dashed var(--border);
        border-radius: var(--radius-xl);
        color: var(--text-secondary);
        font-size: 13px;
        text-align: center;
        background: color-mix(in srgb, var(--bg-secondary) 90%, #fff 10%);
    }
    .build-event {
        display: grid;
        grid-template-columns: 72px 1fr;
        align-items: start;
        gap: 10px;
        border-radius: var(--radius-xl);
        border: 1px solid var(--border);
        background: color-mix(in srgb, var(--bg-secondary) 88%, #fff 12%);
        padding: 9px 10px;
        opacity: 0;
        transform: translateY(4px);
        animation: buildSlideIn 220ms ease forwards;
    }
    .build-event-time {
        margin: 2px 0 0 0;
        font-size: 11px;
        color: var(--text-muted);
        font-weight: 600;
    }
    .build-event-text {
        margin: 0;
        font-size: 13px;
        line-height: 1.35;
        color: var(--text-primary);
        overflow-wrap: anywhere;
    }
    .build-event.success {
        border-color: color-mix(in srgb, #22c55e 40%, var(--border));
    }
    .build-event.success .build-event-text {
        color: color-mix(in srgb, #166534 76%, var(--text-primary) 24%);
    }
    .build-event.error {
        border-color: color-mix(in srgb, #ef4444 45%, var(--border));
    }
    .build-event.error .build-event-text {
        color: color-mix(in srgb, #991b1b 78%, var(--text-primary) 22%);
    }
    .build-event.muted {
        opacity: 0.92;
    }
    .build-nodes {
        padding: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
        min-height: 160px;
    }
    .build-node-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 999px;
        border: 1px solid color-mix(in srgb, #22c55e 45%, var(--border));
        background: color-mix(in srgb, #dcfce7 60%, var(--bg-card) 40%);
        padding: 6px 10px;
        font-size: 12px;
        font-weight: 600;
        color: #166534;
    }
    .build-node-chip::before {
        content: "";
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: #22c55e;
    }
    .build-stop-form {
        margin: 0;
    }
    .token-list {
        margin: 0;
        padding: 10px 12px 12px 12px;
        list-style: none;
        display: grid;
        gap: 8px;
    }
    .token-item {
        border-radius: var(--radius-xl);
        border: 1px solid var(--border);
        background: color-mix(in srgb, var(--bg-secondary) 88%, #fff 12%);
        padding: 8px 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        font-size: 12px;
    }
    .token-node {
        color: var(--text-secondary);
        font-weight: 600;
        overflow-wrap: anywhere;
    }
    .token-total {
        color: var(--text-primary);
        font-weight: 700;
        font-variant-numeric: tabular-nums;
    }
    @keyframes buildSlideIn {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    @keyframes buildPulse {
        0% { box-shadow: 0 0 0 0 rgba(20, 184, 166, 0.5); }
        70% { box-shadow: 0 0 0 9px rgba(20, 184, 166, 0); }
        100% { box-shadow: 0 0 0 0 rgba(20, 184, 166, 0); }
    }
    @media (max-width: 980px) {
        .build-grid {
            grid-template-columns: 1fr;
        }
        .build-metrics {
            grid-template-columns: 1fr;
        }
    }
</style>

<section class="build-shell">
    <section class="build-hero">
        <div class="build-hero-top">
            <div>
                <h1 class="build-title">{{.Project.Name}} Build</h1>
                <p class="build-subline">{{if .Project.RunID}}Run: {{.Project.RunID}}{{else}}Preparing run...{{end}}</p>
            </div>
            <div style="display: inline-flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                <div id="build-status-pill" class="build-pill">
                    <span class="build-pill-dot"></span>
                    <span id="build-status-text">connecting</span>
                </div>
                <form method="POST" action="/projects/{{.Project.ID}}/build/stop" class="build-stop-form">
                    <button type="submit" class="btn btn-danger">Stop</button>
                </form>
            </div>
        </div>
        <section class="build-graph-shell">
            <div class="build-graph-head">
                <h2 class="build-graph-title">Pipeline Diagram</h2>
                <span id="build-graph-status" class="build-graph-status">Rendering diagramâ€¦</span>
            </div>
            <div id="build-graph" class="build-graph">
                <div class="build-graph-empty">Rendering pipeline diagram...</div>
            </div>
        </section>
        <div class="build-metrics">
            <div class="build-metric">
                <p class="build-metric-label">Current Node</p>
                <p id="metric-current-node" class="build-metric-value">-</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Completed Nodes</p>
                <p id="metric-completed-count" class="build-metric-value">0</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Connection</p>
                <p id="metric-connection" class="build-metric-value">Connecting</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Tool Calls</p>
                <p id="metric-tool-calls" class="build-metric-value">0</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Elapsed</p>
                <p id="metric-elapsed" class="build-metric-value">00:00</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Last Activity</p>
                <p id="metric-last-activity" class="build-metric-value">Waiting</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Total Tokens</p>
                <p id="metric-total-tokens" class="build-metric-value">0</p>
            </div>
            <div class="build-metric">
                <p class="build-metric-label">Build Pulse</p>
                <p id="metric-pulse" class="build-metric-value">Starting</p>
            </div>
        </div>
    </section>

    <section class="build-grid">
        <section class="build-card">
            <div class="build-card-head">
                <h2 class="build-card-title">Live Timeline</h2>
                <div id="connection-badge" class="build-connection">
                    <span class="build-connection-dot"></span>
                    <span id="connection-text">connecting</span>
                </div>
            </div>
            <div id="build-events" class="build-events">
                <div class="build-empty">Connecting to build events...</div>
            </div>
        </section>

        <div class="build-side">
            <section class="build-card">
                <div class="build-card-head">
                    <h2 class="build-card-title">Completed Nodes</h2>
                </div>
                <div id="completed-nodes" class="build-nodes"></div>
            </section>
            <section class="build-card">
                <div class="build-card-head">
                    <h2 class="build-card-title">Token Usage by Node</h2>
                </div>
                <ul id="token-nodes" class="token-list">
                    <li class="token-item"><span class="token-node">No token usage yet</span><span class="token-total">0</span></li>
                </ul>
            </section>
        </div>
    </section>
</section>

<script src="https://cdn.jsdelivr.net/npm/@viz-js/viz@3.11.0/lib/viz-standalone.js"></script>
<script>
(function() {
    var projectID = '{{.Project.ID}}';
    var projectDOT = {{ printf "%q" .Project.DOT }};
    var finalURL = '/projects/' + projectID + '/final';
    var stateURL = '/projects/' + projectID + '/build/state';
    var eventsURL = '/projects/' + projectID + '/build/events';

    var eventsDiv = document.getElementById('build-events');
    var nodesContainer = document.getElementById('completed-nodes');
    var metricCurrentNode = document.getElementById('metric-current-node');
    var metricCompletedCount = document.getElementById('metric-completed-count');
    var metricConnection = document.getElementById('metric-connection');
    var metricToolCalls = document.getElementById('metric-tool-calls');
    var metricElapsed = document.getElementById('metric-elapsed');
    var metricLastActivity = document.getElementById('metric-last-activity');
    var metricTotalTokens = document.getElementById('metric-total-tokens');
    var metricPulse = document.getElementById('metric-pulse');
    var tokenNodesList = document.getElementById('token-nodes');
    var graphContainer = document.getElementById('build-graph');
    var graphStatus = document.getElementById('build-graph-status');
    var statusPill = document.getElementById('build-status-pill');
    var statusText = document.getElementById('build-status-text');
    var connectionBadge = document.getElementById('connection-badge');
    var connectionText = document.getElementById('connection-text');

    var source = null;
    var reconnectTimer = null;
    var seenCompletions = {};
    var seenEventKeys = {};
    var isTerminal = false;
    var toolCallsSeen = {};
    var toolCallCount = 0;
    var shouldReconnect = false;
    var elapsedTimer = null;
    var activityTimer = null;
    var startedAt = null;
    var lastActivityAt = null;
    var totalTokens = 0;
    var nodeTokenTotals = {};
    var tokenEventsSeen = {};
    var activeGraphNode = '';
    var redirectedToFinal = false;

    function setStatus(status) {
        statusPill.classList.remove('running', 'completed', 'failed', 'cancelled');
        var text = status || 'unknown';
        if (status === 'running') {
            statusPill.classList.add('running');
        } else if (status === 'completed') {
            statusPill.classList.add('completed');
        } else if (status === 'failed') {
            statusPill.classList.add('failed');
        } else if (status === 'cancelled') {
            statusPill.classList.add('cancelled');
        }
        statusText.textContent = text;
        isTerminal = status === 'completed' || status === 'failed' || status === 'cancelled';
        if (status === 'running') {
            startElapsedTimer();
            metricPulse.textContent = 'Active';
        } else {
            stopElapsedTimer();
            stopActivityTimer();
            if (status === 'completed') {
                metricPulse.textContent = 'Complete';
            } else if (status === 'failed') {
                metricPulse.textContent = 'Failed';
            } else if (status === 'cancelled') {
                metricPulse.textContent = 'Stopped';
            }
        }
    }

    function setConnection(state) {
        connectionBadge.classList.remove('connected', 'reconnecting', 'offline');
        if (state === 'connected') {
            connectionBadge.classList.add('connected');
            connectionText.textContent = 'live';
            metricConnection.textContent = 'Live';
        } else if (state === 'reconnecting') {
            connectionBadge.classList.add('reconnecting');
            connectionText.textContent = 'reconnecting';
            metricConnection.textContent = 'Reconnecting';
        } else {
            connectionBadge.classList.add('offline');
            connectionText.textContent = 'offline';
            metricConnection.textContent = 'Offline';
        }
    }

    function connectStream() {
        if (isTerminal || !shouldReconnect) {
            return;
        }
        if (source) {
            source.close();
        }
        source = new EventSource(eventsURL);
        setConnection('connected');

        source.addEventListener('pipeline.started', function() {
            addEvent('Pipeline started', 'success');
            setStatus('running');
        });

        source.addEventListener('stage.started', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            addEvent('Stage started: ' + node, 'normal');
            metricCurrentNode.textContent = node;
            setActiveNodeHighlight(node);
        });

        source.addEventListener('stage.completed', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            addEvent('Stage completed: ' + node, 'success');
            appendCompletedNode(node);
        });

        source.addEventListener('stage.failed', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            var reason = data.reason || data.error || '';
            addEvent('Stage failed: ' + node + (reason ? ' - ' + reason : ''), 'error');
        });

        source.addEventListener('stage.retrying', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            var attempt = data.attempt || data.retry_attempt || '';
            addEvent('Stage retrying: ' + node + (attempt ? ' (attempt ' + attempt + ')' : ''), 'muted');
        });

        source.addEventListener('stage.stalled', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            addEvent('Stage stalled: ' + node, 'error');
        });

        source.addEventListener('checkpoint.saved', function(e) {
            var data = safeJSON(e.data);
            var node = data.node_id || 'unknown';
            addEvent('Checkpoint saved' + (node ? ': ' + node : ''), 'muted');
        });

        source.addEventListener('agent.tool_call.start', function(e) {
            var data = safeJSON(e.data);
            registerToolCallStart(data);
            addEvent('Tool start: ' + toolSummary(data), 'normal');
        });

        source.addEventListener('agent.tool_call.end', function(e) {
            var data = safeJSON(e.data);
            addEvent('Tool done: ' + toolSummary(data) + toolDurationSuffix(data), 'success');
        });

        source.addEventListener('agent.llm_turn', function(e) {
            var data = safeJSON(e.data);
            registerLLMTurn(data);
            var inTokens = data.input_tokens || 0;
            var outTokens = data.output_tokens || 0;
            var totalTokens = data.total_tokens || (Number(inTokens) + Number(outTokens));
            addEvent('LLM turn: ' + totalTokens + ' tokens (in ' + inTokens + ', out ' + outTokens + ')', 'muted');
        });

        source.addEventListener('pipeline.completed', function() {
            addEvent('Pipeline completed', 'success');
            setStatus('completed');
            closeStream();
            refreshState();
            setTimeout(function() { window.location.href = finalURL; }, 900);
        });

        source.addEventListener('pipeline.failed', function(e) {
            var data = safeJSON(e.data);
            addEvent('Pipeline failed: ' + (data.error || 'unknown error'), 'error');
            setStatus('failed');
            closeStream();
            refreshState();
        });

        source.onerror = function() {
            closeStream();
            if (!shouldReconnect) {
                setConnection('offline');
                return;
            }
            setConnection('reconnecting');
            refreshState();
            if (shouldReconnect) {
                scheduleReconnect();
            }
        };
    }

    function closeStream() {
        if (source) {
            source.close();
            source = null;
        }
    }

    function scheduleReconnect() {
        if (reconnectTimer || isTerminal) {
            return;
        }
        reconnectTimer = setTimeout(function() {
            reconnectTimer = null;
            connectStream();
        }, 1800);
    }

    function refreshState() {
        fetch(stateURL, { headers: { 'Accept': 'application/json' } })
            .then(function(r) { return r.json(); })
            .then(function(state) {
                renderState(state);
                shouldReconnect = Boolean(state && state.active && !isTerminal);
                if (shouldReconnect && !source) {
                    connectStream();
                }
                if (!shouldReconnect) {
                    closeStream();
                    setConnection('offline');
                }
            })
            .catch(function() {
                addEvent('Unable to fetch build state', 'error');
            });
    }

    function renderState(state) {
        if (!state || typeof state !== 'object') {
            return;
        }
        if (state.status) {
            setStatus(state.status);
            if (state.status === 'completed' && !redirectedToFinal) {
                redirectedToFinal = true;
                setTimeout(function() { window.location.href = finalURL; }, 700);
            }
        }
        if (state.run_state) {
            if (state.run_state.started_at) {
                var parsedStart = new Date(state.run_state.started_at);
                if (!Number.isNaN(parsedStart.getTime())) {
                    startedAt = parsedStart;
                    updateElapsedMetric();
                }
            }
            if (state.run_state.current_node) {
                metricCurrentNode.textContent = state.run_state.current_node;
                setActiveNodeHighlight(state.run_state.current_node);
            }
            if (Array.isArray(state.run_state.completed_nodes)) {
                state.run_state.completed_nodes.forEach(function(nodeID) {
                    appendCompletedNode(nodeID);
                });
            }
        }
        if (Array.isArray(state.recent_events)) {
            state.recent_events.forEach(function(evt) {
                replayEvent(evt);
            });
        }
        if (Array.isArray(state.diagnostics) && state.diagnostics.length > 0 && state.status !== 'running') {
            addEvent(state.diagnostics[0], 'error');
        }
        metricCompletedCount.textContent = String(Object.keys(seenCompletions).length);
    }

    function replayEvent(evt) {
        if (!evt || !evt.event) {
            return;
        }
        var key = eventKey(evt.event, evt.data || '');
        if (seenEventKeys[key]) {
            return;
        }
        seenEventKeys[key] = true;

        var data = safeJSON(evt.data || '{}');
        if (evt.event === 'stage.completed') {
            appendCompletedNode(data.node_id || 'unknown');
            addEvent('Stage completed: ' + (data.node_id || 'unknown'), 'success');
        } else if (evt.event === 'stage.started') {
            addEvent('Stage started: ' + (data.node_id || 'unknown'), 'normal');
        } else if (evt.event === 'stage.failed') {
            addEvent('Stage failed: ' + (data.node_id || 'unknown'), 'error');
        } else if (evt.event === 'stage.retrying') {
            addEvent('Stage retrying: ' + (data.node_id || 'unknown'), 'muted');
        } else if (evt.event === 'stage.stalled') {
            addEvent('Stage stalled: ' + (data.node_id || 'unknown'), 'error');
        } else if (evt.event === 'checkpoint.saved') {
            addEvent('Checkpoint saved' + (data.node_id ? ': ' + data.node_id : ''), 'muted');
        } else if (evt.event === 'agent.tool_call.start') {
            registerToolCallStart(data);
            addEvent('Tool start: ' + toolSummary(data), 'normal');
        } else if (evt.event === 'agent.tool_call.end') {
            addEvent('Tool done: ' + toolSummary(data) + toolDurationSuffix(data), 'success');
        } else if (evt.event === 'agent.llm_turn') {
            registerLLMTurn(data);
            var inTokens = data.input_tokens || 0;
            var outTokens = data.output_tokens || 0;
            var totalTokens = data.total_tokens || (Number(inTokens) + Number(outTokens));
            addEvent('LLM turn: ' + totalTokens + ' tokens (in ' + inTokens + ', out ' + outTokens + ')', 'muted');
        } else if (evt.event === 'pipeline.completed') {
            addEvent('Pipeline completed', 'success');
        } else if (evt.event === 'pipeline.failed') {
            addEvent('Pipeline failed: ' + (data.error || 'unknown error'), 'error');
        } else if (evt.event === 'pipeline.started') {
            addEvent('Pipeline started', 'success');
        }
    }

    function registerToolCallStart(data) {
        if (!data || typeof data !== 'object') {
            return;
        }
        var callID = data.call_id || '';
        if (callID && toolCallsSeen[callID]) {
            return;
        }
        if (callID) {
            toolCallsSeen[callID] = true;
        }
        toolCallCount += 1;
        metricToolCalls.textContent = String(toolCallCount);
    }

    function toolSummary(data) {
        var tool = (data && data.tool_name) ? String(data.tool_name) : 'unknown tool';
        var node = (data && data.node_id) ? String(data.node_id) : '';
        if (node) {
            return tool + ' @ ' + node;
        }
        return tool;
    }

    function toolDurationSuffix(data) {
        if (!data || typeof data !== 'object') {
            return '';
        }
        var ms = Number(data.duration_ms || 0);
        if (!ms || Number.isNaN(ms)) {
            return '';
        }
        if (ms < 1000) {
            return ' (' + ms + 'ms)';
        }
        return ' (' + (ms / 1000).toFixed(2) + 's)';
    }

    function appendCompletedNode(nodeID) {
        if (!nodeID || seenCompletions[nodeID]) {
            return;
        }
        seenCompletions[nodeID] = true;
        var chip = document.createElement('span');
        chip.className = 'build-node-chip';
        chip.textContent = nodeID;
        nodesContainer.appendChild(chip);
        metricCompletedCount.textContent = String(Object.keys(seenCompletions).length);
    }

    function registerLLMTurn(data) {
        if (!data || typeof data !== 'object') {
            return;
        }
        var key = 'llm::' + String(data.turn_id || data.message_id || data.timestamp || JSON.stringify(data));
        if (tokenEventsSeen[key]) {
            return;
        }
        tokenEventsSeen[key] = true;

        var inTokens = Number(data.input_tokens || 0);
        var outTokens = Number(data.output_tokens || 0);
        var turnTotal = Number(data.total_tokens || (inTokens + outTokens));
        if (!Number.isFinite(turnTotal) || turnTotal <= 0) {
            return;
        }

        totalTokens += turnTotal;
        metricTotalTokens.textContent = formatNumber(totalTokens);

        var node = String(data.node_id || metricCurrentNode.textContent || 'unknown');
        if (!nodeTokenTotals[node]) {
            nodeTokenTotals[node] = 0;
        }
        nodeTokenTotals[node] += turnTotal;
        renderNodeTokenTotals();
    }

    function renderNodeTokenTotals() {
        var entries = Object.keys(nodeTokenTotals).map(function(node) {
            return { node: node, total: nodeTokenTotals[node] };
        });
        entries.sort(function(a, b) { return b.total - a.total; });

        if (entries.length === 0) {
            tokenNodesList.innerHTML = '<li class="token-item"><span class="token-node">No token usage yet</span><span class="token-total">0</span></li>';
            return;
        }

        tokenNodesList.innerHTML = '';
        entries.forEach(function(entry) {
            var li = document.createElement('li');
            li.className = 'token-item';

            var nameEl = document.createElement('span');
            nameEl.className = 'token-node';
            nameEl.textContent = entry.node;

            var totalEl = document.createElement('span');
            totalEl.className = 'token-total';
            totalEl.textContent = formatNumber(entry.total);

            li.appendChild(nameEl);
            li.appendChild(totalEl);
            tokenNodesList.appendChild(li);
        });
    }

    function renderPipelineGraph() {
        if (!projectDOT || !projectDOT.trim()) {
            graphStatus.textContent = 'No DOT';
            graphContainer.innerHTML = '<div class="build-graph-empty">No DOT available for this build.</div>';
            return;
        }

        if (typeof Viz === 'undefined') {
            graphStatus.textContent = 'Renderer unavailable';
            graphContainer.innerHTML = '<div class="build-graph-empty">Diagram renderer did not load.</div>';
            return;
        }

        var dotText = normalizeDOTSource(projectDOT);
        renderDOTToSVG(dotText).then(function(svg) {
            graphContainer.innerHTML = svg;
            var svgEl = graphContainer.querySelector('svg');
            if (svgEl) {
                svgEl.classList.add('build-graph-svg');
                svgEl.removeAttribute('width');
                svgEl.removeAttribute('height');
            }
            graphStatus.textContent = 'Live highlighting on';
            if (activeGraphNode) {
                setActiveNodeHighlight(activeGraphNode);
            }
        }).catch(function(err) {
            graphStatus.textContent = 'Render failed';
            var msg = (err && err.message) ? String(err.message) : 'unknown error';
            graphContainer.innerHTML = '<div class="build-graph-empty">Could not render DOT diagram: ' + escapeHTML(msg) + '</div>';
        });
    }

    function renderDOTToSVG(dotText) {
        // viz-js v3 standalone: Viz.instance().then(viz => viz.renderString(...))
        if (Viz && typeof Viz.instance === 'function') {
            return Viz.instance().then(function(viz) {
                return renderWithVizInstance(viz, dotText);
            });
        }
        // legacy API: new Viz().renderString(...)
        if (typeof Viz === 'function') {
            try {
                var legacyViz = new Viz();
                var out = renderWithVizInstance(legacyViz, dotText);
                if (out && typeof out.then === 'function') {
                    return out;
                }
                return Promise.resolve(out);
            } catch (err) {
                return Promise.reject(err);
            }
        }
        return Promise.reject(new Error('viz runtime unavailable'));
    }

    function renderWithVizInstance(viz, dotText) {
        if (!viz) {
            return Promise.reject(new Error('viz instance unavailable'));
        }

        // Try renderString first.
        if (typeof viz.renderString === 'function') {
            try {
                var out = viz.renderString(dotText);
                if (out && typeof out.then === 'function') {
                    return out.then(normalizeRenderedSVG);
                }
                return Promise.resolve(normalizeRenderedSVG(out));
            } catch (_err) {
                // fall through to renderSVGElement
            }
        }

        // Fallback: render SVG element then serialize.
        if (typeof viz.renderSVGElement === 'function') {
            try {
                var svgOut = viz.renderSVGElement(dotText);
                if (svgOut && typeof svgOut.then === 'function') {
                    return svgOut.then(function(el) {
                        return normalizeRenderedSVG(el);
                    });
                }
                return Promise.resolve(normalizeRenderedSVG(svgOut));
            } catch (err2) {
                return Promise.reject(err2);
            }
        }

        return Promise.reject(new Error('viz instance missing render methods'));
    }

    function normalizeRenderedSVG(out) {
        if (typeof out === 'string') {
            var s = out.trim();
            if (s.indexOf('<svg') !== -1) {
                return s;
            }
            throw new Error('renderer returned non-SVG string');
        }

        if (out && typeof out === 'object') {
            if (typeof out.outerHTML === 'string' && out.outerHTML.indexOf('<svg') !== -1) {
                return out.outerHTML;
            }
            if (typeof out.svg === 'string' && out.svg.indexOf('<svg') !== -1) {
                return out.svg;
            }
            if (typeof out.output === 'string' && out.output.indexOf('<svg') !== -1) {
                return out.output;
            }
        }

        throw new Error('renderer returned unsupported output type');
    }

    function normalizeDOTSource(raw) {
        var text = String(raw || '').trim();
        if (!text) {
            return text;
        }

        // Handle DOT accidentally stored as a quoted JSON string.
        if ((text.startsWith('"') && text.endsWith('"')) || (text.startsWith("'") && text.endsWith("'"))) {
            try {
                var parsed = JSON.parse(text);
                if (typeof parsed === 'string' && parsed.trim()) {
                    text = parsed.trim();
                }
            } catch (_err) {
                text = text.slice(1, -1).trim();
            }
        }

        // If escaped newlines survived storage, convert them back.
        if (text.indexOf('\\n') >= 0 && text.indexOf('\n') < 0) {
            text = text.replaceAll('\\n', '\n');
        }
        if (text.indexOf('\\"') >= 0) {
            text = text.replaceAll('\\"', '"');
        }
        return text;
    }

    function escapeHTML(s) {
        return String(s)
            .replaceAll('&', '&amp;')
            .replaceAll('<', '&lt;')
            .replaceAll('>', '&gt;')
            .replaceAll('"', '&quot;')
            .replaceAll("'", '&#39;');
    }

    function setActiveNodeHighlight(nodeID) {
        if (!nodeID || !graphContainer) {
            return;
        }
        activeGraphNode = String(nodeID);
        var nodeEls = graphContainer.querySelectorAll('g.node');
        if (!nodeEls.length) {
            return;
        }
        var highlighted = false;
        nodeEls.forEach(function(el) {
            el.classList.remove('is-active');
            var title = el.querySelector('title');
            if (title && title.textContent === activeGraphNode) {
                el.classList.add('is-active');
                highlighted = true;
            }
        });
        if (highlighted) {
            graphStatus.textContent = 'Active: ' + activeGraphNode;
        }
    }

    function eventKey(event, data) {
        return event + '::' + String(data || '');
    }

    function safeJSON(text) {
        try {
            return JSON.parse(text);
        } catch (_e) {
            return {};
        }
    }

    function formatNumber(n) {
        var num = Number(n || 0);
        if (!Number.isFinite(num)) {
            return '0';
        }
        return Math.floor(num).toLocaleString();
    }

    function addEvent(text, tone) {
        if (!text) {
            return;
        }
        lastActivityAt = new Date();
        updateLastActivityMetric();
        if (eventsDiv.querySelector('.build-empty')) {
            eventsDiv.innerHTML = '';
        }
        var card = document.createElement('article');
        card.className = 'build-event';
        if (tone === 'success') {
            card.classList.add('success');
        } else if (tone === 'error') {
            card.classList.add('error');
        } else if (tone === 'muted') {
            card.classList.add('muted');
        }

        var timeEl = document.createElement('p');
        timeEl.className = 'build-event-time';
        timeEl.textContent = new Date().toLocaleTimeString();

        var textEl = document.createElement('p');
        textEl.className = 'build-event-text';
        textEl.textContent = text;

        card.appendChild(timeEl);
        card.appendChild(textEl);
        eventsDiv.appendChild(card);
        eventsDiv.scrollTop = eventsDiv.scrollHeight;
    }

    function startElapsedTimer() {
        if (!startedAt) {
            startedAt = new Date();
        }
        if (elapsedTimer) {
            return;
        }
        updateElapsedMetric();
        elapsedTimer = setInterval(updateElapsedMetric, 1000);
        startActivityTimer();
    }

    function stopElapsedTimer() {
        if (!elapsedTimer) {
            return;
        }
        clearInterval(elapsedTimer);
        elapsedTimer = null;
    }

    function startActivityTimer() {
        if (activityTimer) {
            return;
        }
        updateLastActivityMetric();
        activityTimer = setInterval(updateLastActivityMetric, 1000);
    }

    function stopActivityTimer() {
        if (!activityTimer) {
            return;
        }
        clearInterval(activityTimer);
        activityTimer = null;
    }

    function updateElapsedMetric() {
        if (!startedAt) {
            metricElapsed.textContent = '00:00';
            return;
        }
        var seconds = Math.max(0, Math.floor((Date.now() - startedAt.getTime()) / 1000));
        var mins = Math.floor(seconds / 60);
        var secs = seconds % 60;
        metricElapsed.textContent = String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
    }

    function updateLastActivityMetric() {
        if (!lastActivityAt) {
            metricLastActivity.textContent = 'Waiting';
            return;
        }
        var seconds = Math.max(0, Math.floor((Date.now() - lastActivityAt.getTime()) / 1000));
        if (seconds < 5) {
            metricLastActivity.textContent = 'Just now';
            metricPulse.textContent = 'Active';
            return;
        }
        metricLastActivity.textContent = seconds + 's ago';
        metricPulse.textContent = seconds > 20 ? ('Quiet ' + seconds + 's') : 'Active';
    }

    renderPipelineGraph();
    refreshState();
    startActivityTimer();
})();
</script>
{{end}}
