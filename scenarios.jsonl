{"name":"pipeline_lifecycle","description":"Full pipeline lifecycle from DOT file to final outcome","given":"A DOT pipeline file with plan/implement/review nodes and goal_gate","when":"Parsed, validated, transformed, and executed through the real engine","then":"All nodes complete, artifacts written to disk, checkpoints saved, events emitted in correct order, context contains goal and outputs","validates":["parser","validator","transforms","engine","handlers","artifacts","checkpoints","events"]}
{"name":"http_server_lifecycle","description":"HTTP server submit/poll/stream/query end-to-end","given":"A PipelineServer with real engine and render functions","when":"Pipeline submitted via POST, status polled, SSE streamed, events queried/tailed/summarized, graph rendered","then":"All HTTP endpoints return correct status codes, valid JSON/SSE, proper filtering, and DOT graph output","validates":["server","sse_streaming","event_query","event_tail","event_summary","graph_rendering"]}
{"name":"checkpoint_resume","description":"Checkpoint save and resume with fidelity degradation","given":"A 5-node pipeline with full fidelity on one edge","when":"Executed to completion, checkpoint loaded from mid-pipeline, resumed from checkpoint","then":"Checkpoint files exist on disk, resume executes only post-checkpoint nodes, fidelity degrades to summary:high on first hop, final outcome matches fresh run","validates":["checkpoints","resume","fidelity_degradation","context_restoration"]}
{"name":"parallel_execution","description":"Parallel fan-out/fan-in with multiple join and error policies","given":"A pipeline with parallel fork, 3 branches, and fan-in node","when":"Executed with wait_all, wait_any, k_of_n, and fail_fast policies","then":"Branches execute concurrently, context merges correctly, branch isolation maintained, artifact manifests consolidated, failed branches handled per policy","validates":["parallel","fan_in","context_merge","branch_isolation","join_policies","error_policies","artifact_consolidation"]}
{"name":"human_gate_http","description":"Human-in-the-loop approve/reject flow via HTTP","given":"A pipeline with a human gate node served via HTTP","when":"Pipeline submitted, question polled, answer posted (approve or reject)","then":"Pipeline blocks at gate, question has correct prompt/options, answer unblocks execution, response stored in context, correct terminal node reached","validates":["human_gate","http_questions","http_answers","conditional_routing"]}
{"name":"error_recovery","description":"Retry, goal gate retry, loop restart, and conditional error routing","given":"Pipelines with failing nodes, retry policies, goal gates, and loop_restart edges","when":"Nodes fail with configurable patterns","then":"Retries execute correct number of times, goal gate triggers re-execution, loop restart creates fresh context, conditional edges route to error handlers, max limits enforced","validates":["retry","max_retry","goal_gate_retry","loop_restart","max_restarts","conditional_error_routing","retry_events","failure_events"]}
